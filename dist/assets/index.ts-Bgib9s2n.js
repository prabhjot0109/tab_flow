const $="/assets/index.ts-CRE4RUJB.js";class H{dbName;storeName;db;initPromise;constructor(s,t){this.dbName=s,this.storeName=t,this.db=null,this.initPromise=this._open()}_open(){return new Promise((s,t)=>{const r=indexedDB.open(this.dbName,1);r.onerror=()=>t(r.error),r.onsuccess=()=>{this.db=r.result,s(this.db)},r.onupgradeneeded=o=>{const a=o.target.result;a.objectStoreNames.contains(this.storeName)||a.createObjectStore(this.storeName)}})}async getAll(){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((s,t)=>{const a=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();a.onsuccess=()=>s(a.result),a.onerror=()=>t(a.error)})}async getAllKeys(){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((s,t)=>{const a=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAllKeys();a.onsuccess=()=>s(a.result),a.onerror=()=>t(a.error)})}async set(s,t){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((r,o)=>{const n=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).put(t,s);n.onsuccess=()=>r(),n.onerror=()=>o(n.error)})}async delete(s){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((t,r)=>{const c=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(s);c.onsuccess=()=>t(),c.onerror=()=>r(c.error)})}async clear(){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((s,t)=>{const a=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();a.onsuccess=()=>s(),a.onerror=()=>t(a.error)})}}class G{cache;maxTabs;maxBytes;currentBytes;accessOrder;storage;ready;constructor(s=30,t=20*1024*1024){this.cache=new Map,this.maxTabs=s,this.maxBytes=t,this.currentBytes=0,this.accessOrder=[],this.storage=new H("TabSwitcherDB","screenshots"),this.ready=this._restoreFromStorage()}async _restoreFromStorage(){try{const s=await this.storage.getAllKeys();if(s.length===0)return;const t=await this.storage.getAll();s.forEach((r,o)=>{const a=t[o];if(typeof r!="number"||!a||typeof a!="object")return;const c=a;typeof c.data=="string"&&typeof c.size=="number"&&typeof c.timestamp=="number"&&(this.cache.set(r,c),this.currentBytes+=c.size)}),this.accessOrder=Array.from(this.cache.entries()).sort((r,o)=>o[1].timestamp-r[1].timestamp).map(r=>r[0]),console.log(`[CACHE] Restored ${this.cache.size} screenshots from storage`)}catch(s){console.error("[CACHE] Failed to restore from storage:",s)}}get(s){if(!this.cache.has(s))return null;this.accessOrder=this.accessOrder.filter(r=>r!==s),this.accessOrder.unshift(s);const t=this.cache.get(s);return t.timestamp=Date.now(),this.storage.set(s,t).catch(r=>console.warn("Failed to update timestamp",r)),t}set(s,t){const r=this._estimateSize(t);if(this.cache.has(s)){const a=this.cache.get(s).size;this.currentBytes-=a}for(;(this.cache.size>=this.maxTabs||this.currentBytes+r>this.maxBytes)&&this.cache.size>0;)this._evictLRU();const o={data:t,size:r,timestamp:Date.now()};this.cache.set(s,o),this.currentBytes+=r,this.accessOrder=this.accessOrder.filter(a=>a!==s),this.accessOrder.unshift(s),this.storage.set(s,o).catch(a=>console.error("Failed to persist screenshot",a))}delete(s){if(!this.cache.has(s))return!1;const t=this.cache.get(s);return t?(this.currentBytes-=t.size,this.cache.delete(s),this.accessOrder=this.accessOrder.filter(r=>r!==s),this.storage.delete(s).catch(r=>console.error("Failed to delete screenshot",r)),!0):!1}_evictLRU(){if(this.accessOrder.length===0)return;const s=this.accessOrder.pop();if(s===void 0)return;const t=this.cache.get(s);t&&(this.currentBytes-=t.size,this.cache.delete(s),this.storage.delete(s).catch(r=>console.warn("Failed to evict from storage",r)),console.debug(`[LRU] Evicted tab ${s} (${(t.size/1024).toFixed(1)}KB)`))}_estimateSize(s){return Math.ceil(s.length*.75)}getStats(){return{entries:this.cache.size,bytes:this.currentBytes,maxTabs:this.maxTabs,maxBytes:this.maxBytes,utilizationPercent:(this.currentBytes/this.maxBytes*100).toFixed(1)}}clear(){this.cache.clear(),this.accessOrder=[],this.currentBytes=0,this.storage.clear().catch(s=>console.error("Failed to clear storage",s))}}const d={MAX_CACHED_TABS:30,MAX_CACHE_BYTES:20*1024*1024,MAX_SCREENSHOT_SIZE:200*1024,JPEG_QUALITY:60,CAPTURE_DELAY:100,SCREENSHOT_CACHE_DURATION:300*1e3,MAX_CAPTURES_PER_SECOND:2,THROTTLE_INTERVAL:500,PERFORMANCE_LOGGING:!0,QUALITY_TIERS:{HIGH:{quality:80,maxSize:300*1024,label:"High Quality"},NORMAL:{quality:60,maxSize:200*1024,label:"Normal"},PERFORMANCE:{quality:40,maxSize:100*1024,label:"Performance"}},DEFAULT_QUALITY_TIER:"PERFORMANCE"},g=new G(d.MAX_CACHED_TABS,d.MAX_CACHE_BYTES);let m=[];const T=new Map,y=[];let N=0,v=!1,w=null,E=d.DEFAULT_QUALITY_TIER;const p=new Set;let P=!1;const u=new Set;function A(){try{chrome.storage.session.set({tabsWithMedia:Array.from(u)})}catch{}}async function Q(){try{const e=await chrome.storage.session.get("tabsWithMedia");e.tabsWithMedia&&Array.isArray(e.tabsWithMedia)&&e.tabsWithMedia.forEach(s=>u.add(s))}catch{}}Q();async function W(){try{const e=await chrome.tabs.query({audible:!0});for(const t of e)t.id&&!u.has(t.id)&&u.add(t.id);const s=await chrome.tabs.query({});for(const t of s)t.id&&t.mutedInfo?.muted&&!u.has(t.id)&&u.add(t.id);u.size>0&&(A(),console.log(`[MEDIA] Initialized ${u.size} tabs with media`))}catch(e){console.debug("[MEDIA] Error initializing audible tabs:",e)}}setTimeout(W,200);const I={overlayOpenTimes:[],captureCount:0,cacheHits:0,cacheMisses:0,recordOverlayOpen(e){this.overlayOpenTimes.push(e),this.overlayOpenTimes.length>100&&this.overlayOpenTimes.shift(),console.log(`[PERF] Overlay open: ${e.toFixed(2)}ms (Target: <100ms)`)},getAverageOverlayTime(){return this.overlayOpenTimes.length===0?0:this.overlayOpenTimes.reduce((s,t)=>s+t,0)/this.overlayOpenTimes.length},logStats(){const e=g.getStats(),s=this.getAverageOverlayTime();console.log("[STATS] ═══════════════════════════════════════"),console.log(`[STATS] Cache: ${e.entries}/${e.maxTabs} tabs`),console.log(`[STATS] Memory: ${(e.bytes/1024/1024).toFixed(2)}MB / ${(e.maxBytes/1024/1024).toFixed(2)}MB (${e.utilizationPercent}%)`),console.log(`[STATS] Captures: ${this.captureCount} (Hits: ${this.cacheHits}, Misses: ${this.cacheMisses})`),console.log(`[STATS] Avg Overlay Open: ${s.toFixed(2)}ms (Target: <100ms)`),console.log("[STATS] ═══════════════════════════════════════")}};function S(e,s=!1){if(y.some(r=>r.tabId===e)||p.has(e))return;const t={tabId:e,timestamp:Date.now()};s?y.unshift(t):y.push(t),Y()}async function Y(){if(!(v||y.length===0)){for(v=!0;y.length>0;){const s=Date.now()-N;if(s<d.THROTTLE_INTERVAL){const r=d.THROTTLE_INTERVAL-s;await new Promise(o=>setTimeout(o,r))}const t=y.shift();if(t&&t.tabId){p.add(t.tabId);try{await B(t.tabId)}finally{p.delete(t.tabId)}}N=Date.now()}v=!1}}async function B(e,s=null){try{const t=await chrome.tabs.get(e);if(!t.active)return console.debug(`[CAPTURE] Tab ${e} is not active, skipping capture`),null;if(!R(t))return console.debug(`[CAPTURE] Tab ${e} not capturable: ${t.url}`),null;await new Promise(b=>setTimeout(b,d.CAPTURE_DELAY+50));const r=await chrome.tabs.get(e).catch(()=>null);if(!r||!r.active)return console.debug(`[CAPTURE] Tab ${e} no longer active after delay`),null;const o=s||E,a=d.QUALITY_TIERS[o]||d.QUALITY_TIERS.NORMAL,c=performance.now();let n=null;try{n=await chrome.tabs.captureVisibleTab(t.windowId,{format:"jpeg",quality:a.quality})}catch{console.debug("[CAPTURE] First attempt failed, retrying with lower quality");try{await new Promise(f=>setTimeout(f,100)),n=await chrome.tabs.captureVisibleTab(t.windowId,{format:"jpeg",quality:Math.max(30,a.quality-20)})}catch(f){const i=f instanceof Error?f.message:typeof f=="string"?f:String(f);return console.debug(`[CAPTURE] Retry also failed for tab ${e}:`,i),null}}if(!n)return console.debug(`[CAPTURE] No screenshot data for tab ${e}`),null;const l=performance.now()-c,h=g._estimateSize(n);return h>a.maxSize*1.5&&console.warn(`[CAPTURE] Screenshot large: ${(h/1024).toFixed(1)}KB (target: ${(a.maxSize/1024).toFixed(1)}KB)`),g.set(e,n),I.captureCount++,d.PERFORMANCE_LOGGING&&console.debug(`[CAPTURE] Tab ${e}: ${l.toFixed(2)}ms, ${(h/1024).toFixed(1)}KB (${a.label})`),n}catch(t){const r=t instanceof Error?t.message:typeof t=="string"?t:String(t);return console.debug(`[CAPTURE] Failed for tab ${e}:`,r),null}}function R(e){if(e.discarded||!e.url)return!1;const s=["chrome://","edge://","devtools://","view-source:"];return!(e.url&&s.some(t=>e.url.startsWith(t)))}typeof chrome<"u"&&chrome.tabs?(chrome.tabs.onActivated.addListener(async e=>{try{w=e.tabId,x=Date.now(),F(e.tabId),setTimeout(()=>{S(e.tabId,!0)},200)}catch(s){console.debug("[TAB] Error in onActivated:",s)}}),chrome.tabs.onUpdated.addListener((e,s,t)=>{try{s.audible!==void 0&&s.audible&&(u.has(e)||(u.add(e),A(),console.debug(`[MEDIA] Tab ${e} became audible, marked as having media`))),s.status==="complete"&&t.active&&setTimeout(()=>{S(e,!0)},300)}catch(r){console.debug("[TAB] Error in onUpdated:",r)}}),chrome.tabs.onCreated.addListener(e=>{try{e.id&&T.set(e.id,Date.now())}catch(s){console.debug("[TAB] Error in onCreated:",s)}}),chrome.tabs.onRemoved.addListener(e=>{try{g.delete(e),U(e),T.delete(e),p.delete(e),u.has(e)&&(u.delete(e),A()),console.debug(`[CLEANUP] Removed tab ${e} from cache`)}catch(s){console.debug("[TAB] Error in onRemoved:",s)}})):console.error("[INIT] chrome.tabs API not available");let x=Date.now();setInterval(async()=>{try{if(!w)return;const e=300*1e3;Date.now()-x>e&&(console.debug(`[IDLE] Tab ${w} idle > 5m, refreshing screenshot`),x=Date.now(),S(w,!0))}catch(e){console.debug("[IDLE] Error in idle check:",e)}},60*1e3);function F(e){U(e),m.unshift(e),m.length>d.MAX_CACHED_TABS*2&&(m.length=d.MAX_CACHED_TABS*2),j()}function U(e){const s=m.indexOf(e);s!==-1&&m.splice(s,1)}let M=null;function j(){M&&clearTimeout(M),M=setTimeout(()=>{chrome.storage.local.set({recentTabOrder:m.slice(0,100)}).catch(e=>console.debug("[STORAGE] Failed to save recent order:",e))},500)}async function D(){try{const e=await chrome.storage.local.get(["recentTabOrder"]);if(e.recentTabOrder&&Array.isArray(e.recentTabOrder)){const s=await chrome.tabs.query({}),t=new Set(s.map(r=>r.id));m=e.recentTabOrder.filter(r=>t.has(r)),console.log(`[INIT] Restored ${m.length} recent tab order entries`)}}catch(e){console.debug("[STORAGE] Failed to restore recent order:",e)}P=!0}typeof chrome<"u"&&chrome.commands&&chrome.commands.onCommand.addListener(e=>{(e==="show-tab-switcher"||e==="cycle-next-tab")&&L()});async function L(){g.ready&&await g.ready,P||await D();const e=performance.now();try{const s=await chrome.windows.getCurrent(),t=await chrome.tabs.query({windowId:s.id}),r=t.filter(i=>typeof i.id=="number");let o=[];if(chrome.tabGroups)try{o=await chrome.tabGroups.query({windowId:s.id})}catch(i){console.debug("[GROUPS] Failed to fetch groups:",i)}const a=Date.now();r.forEach((i,O)=>{T.has(i.id)||T.set(i.id,a-(t.length-O)*1e3)});const c=K(r),n=8,l=c.map((i,O)=>{let C=null;const z=O<n;if(R(i)&&z){const _=g.get(i.id);_?(C=_,I.cacheHits++):I.cacheMisses++}return{id:i.id,title:i.title||"Untitled",url:i.url,favIconUrl:i.favIconUrl,screenshot:C?C.data:null,pinned:i.pinned,index:i.index,active:i.active,audible:i.audible,mutedInfo:i.mutedInfo,groupId:i.groupId,hasMedia:u.has(i.id)||i.audible}}),h=o.map(i=>({id:i.id,title:i.title,color:i.color,collapsed:i.collapsed})),[b]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!b||typeof b.id!="number"){console.warn("[INJECT] No active tab found to open overlay");return}if(!R(b)){console.warn("[INJECT] Cannot open overlay on protected page. Switch to a regular webpage and try again.");return}await X(b.id,{action:"showTabSwitcher",tabs:l,groups:h,activeTabId:b.id});const f=performance.now()-e;I.recordOverlayOpen(f)}catch(s){console.error("[ERROR] Failed to show tab switcher:",s)}}async function X(e,s,t=1){try{await chrome.tabs.sendMessage(e,s)}catch(r){if(t>0&&r.message&&r.message.includes("Could not establish connection")){console.log("[INJECT] Content script not ready, injecting...");try{await chrome.scripting.executeScript({target:{tabId:e},files:[$]}),await new Promise(o=>setTimeout(o,150)),await chrome.tabs.sendMessage(e,s)}catch(o){const a=o&&o.message?o.message:"";if(a.includes("cannot be scripted")||a.includes("Cannot access a chrome://")||a.includes("Cannot access a chrome-extension://")||a.includes("Cannot access")&&a.includes("URL"))console.warn("[INJECT] Cannot inject on this page (protected URL). Try on a regular webpage.");else throw o}}else throw r}}function K(e){return[...e].sort((s,t)=>{const r=s.lastAccessed||0,o=t.lastAccessed||0;if(r&&o)return o-r;if(r)return-1;if(o)return 1;const a=typeof s.id=="number"?m.indexOf(s.id):-1,c=typeof t.id=="number"?m.indexOf(t.id):-1;if(a!==-1&&c!==-1)return a-c;if(a!==-1)return-1;if(c!==-1)return 1;const n=typeof s.id=="number"?T.get(s.id)??0:0,l=typeof t.id=="number"?T.get(t.id)??0:0;return n!==l?l-n:(t.index??0)-(s.index??0)})}typeof chrome<"u"&&chrome.runtime&&chrome.runtime.onMessage&&chrome.runtime.onMessage.addListener((e,s,t)=>(V(e,s,t),!0));async function V(e,s,t){try{if(!e||!e.action){console.error("[ERROR] Invalid message received:",e),t({success:!1,error:"Invalid message format"});return}switch(e.action){case"reportMediaPresence":s.tab&&s.tab.id&&(u.has(s.tab.id)||(u.add(s.tab.id),A())),t({success:!0});break;case"getRecentlyClosed":try{const o=Math.min(25,typeof e.maxResults=="number"?e.maxResults:10),a=await chrome.sessions.getRecentlyClosed({maxResults:25}),c=[];for(const l of a)if(l.tab)c.push({kind:"tab",sessionId:l.tab.sessionId,lastModified:l.lastModified,title:l.tab.title||"Untitled",url:l.tab.url||"",favIconUrl:l.tab.favIconUrl||""});else if(l.window&&Array.isArray(l.window.tabs))for(const h of l.window.tabs)c.push({kind:"tab",sessionId:h.sessionId||l.window.sessionId,lastModified:l.lastModified,title:h.title||"Untitled",url:h.url||"",favIconUrl:h.favIconUrl||""});else l.window&&l.window.sessionId&&c.push({kind:"window",sessionId:l.window.sessionId,lastModified:l.lastModified,title:"Window",url:"",favIconUrl:""});c.sort((l,h)=>(h.lastModified||0)-(l.lastModified||0));const n=c.slice(0,o);t({success:!0,items:n})}catch(r){console.error("[ERROR] Failed to get recently closed:",r),t({success:!1,error:r.message})}break;case"restoreSession":try{if(!e.sessionId||typeof e.sessionId!="string"){t({success:!1,error:"Invalid sessionId"});return}const r=await chrome.sessions.restore(e.sessionId);t({success:!0,restored:r})}catch(r){console.error("[ERROR] Failed to restore session:",r),t({success:!1,error:r.message})}break;case"switchToTab":if(!e.tabId||typeof e.tabId!="number"){t({success:!1,error:"Invalid tab ID"});return}try{await chrome.tabs.update(e.tabId,{active:!0}),t({success:!0})}catch(r){console.error("[ERROR] Failed to switch to tab:",r),t({success:!1,error:r.message})}break;case"closeTab":if(!e.tabId||typeof e.tabId!="number"){t({success:!1,error:"Invalid tab ID"});return}try{if(!await chrome.tabs.get(e.tabId).catch(()=>null)){console.warn("[WARNING] Tab no longer exists:",e.tabId),t({success:!1,error:"Tab no longer exists"});return}await chrome.tabs.remove(e.tabId),t({success:!0})}catch(r){console.error("[ERROR] Failed to close tab:",r),t({success:!1,error:r.message})}break;case"toggleMute":if(!e.tabId||typeof e.tabId!="number"){t({success:!1,error:"Invalid tab ID"});return}try{const o=!((await chrome.tabs.get(e.tabId)).mutedInfo?.muted??!1);await chrome.tabs.update(e.tabId,{muted:o}),t({success:!0,muted:o})}catch(r){console.error("[ERROR] Failed to toggle mute:",r),t({success:!1,error:r.message})}break;case"togglePlayPause":if(!e.tabId||typeof e.tabId!="number"){t({success:!1,error:"Invalid tab ID"});return}try{const r=await chrome.tabs.get(e.tabId);if(R(r)){const o=await chrome.scripting.executeScript({target:{tabId:e.tabId},func:()=>{const a=[...document.querySelectorAll("video, audio")];return a.length===0?{success:!1,reason:"no_media"}:a.some(n=>!n.paused&&!n.ended)?(a.forEach(n=>n.pause()),{success:!0,playing:!1}):(a.forEach(n=>n.play().catch(()=>{})),{success:!0,playing:!0})}});o&&o[0]?t({success:!0,...o[0].result}):t({success:!1,error:"Script execution failed"})}else t({success:!1,error:"Cannot script in this tab"})}catch(r){console.error("[ERROR] Failed to toggle play/pause:",r),t({success:!1,error:r.message})}break;case"refreshTabList":try{await L(),t({success:!0})}catch(r){console.error("[ERROR] Failed to refresh tab list:",r),t({success:!1,error:r.message})}break;case"captureTabScreenshot":if(!e.tabId||typeof e.tabId!="number"){t({success:!1,error:"Invalid tab ID"});return}try{const r=await B(e.tabId,null);t({success:!!r,screenshot:r})}catch(r){console.error("[ERROR] Failed to capture screenshot:",r),t({success:!1,error:r.message})}break;case"getCacheStats":try{const r=g.getStats();t({success:!0,stats:r})}catch(r){console.error("[ERROR] Failed to get cache stats:",r),t({success:!1,error:r.message})}break;case"setQualityTier":try{const r=e.tier||d.DEFAULT_QUALITY_TIER;d.QUALITY_TIERS[r]?(E=r,chrome.storage.local.set({qualityTier:r}),console.log(`[SETTINGS] Quality tier changed to: ${r}`),t({success:!0,tier:r})):t({success:!1,error:"Invalid quality tier"})}catch(r){console.error("[ERROR] Failed to set quality tier:",r),t({success:!1,error:r.message})}break;case"createGroup":try{if(e.tabId&&chrome.tabs.group){const r=await chrome.tabs.group({tabIds:e.tabId});t({success:!0,groupId:r})}else t({success:!1,error:"Missing tabId or API not supported"})}catch(r){console.error("[GROUPS] Failed to create group:",r),t({success:!1,error:r.message})}break;default:console.warn("[WARNING] Unknown action:",e.action),t({success:!1,error:"Unknown action"})}}catch(r){console.error("[ERROR] Message handler failed:",r),t({success:!1,error:r.message})}}setInterval(()=>{I.logStats()},6e4);async function k(){try{await D();const e=await chrome.tabs.query({}),s=Date.now();e.forEach((r,o)=>{r.id&&!T.has(r.id)&&T.set(r.id,s-(e.length-o)*1e3)});const t=await chrome.windows.getAll();for(const r of t){const[o]=await chrome.tabs.query({windowId:r.id,active:!0});o&&o.id&&(m.indexOf(o.id)===-1&&F(o.id),w=o.id,setTimeout(()=>{o.id&&S(o.id,!0)},500))}console.log(`[INIT] Initialized ${e.length} existing tabs, ${m.length} in recent order`)}catch(e){console.error("[INIT] Failed to initialize existing tabs:",e)}}console.log("[INIT] Visual Tab Switcher initialized");chrome.storage.local.get(["qualityTier"],e=>{try{const s=e&&e.qualityTier,t=d&&d.QUALITY_TIERS;s&&t&&t[s]?(E=s,console.log(`[INIT] Loaded quality tier: ${E}`)):console.log("[INIT] Using default quality tier:",E)}catch(s){const t=s instanceof Error?s.message:typeof s=="string"?s:String(s);console.warn("[INIT] Failed to load quality tier, using default:",t)}});setTimeout(k,100);console.log("═══════════════════════════════════════════════════════");console.log("Visual Tab Switcher - Performance Optimized");console.log("═══════════════════════════════════════════════════════");console.log(`Cache: Max ${d.MAX_CACHED_TABS} tabs, ${(d.MAX_CACHE_BYTES/1024/1024).toFixed(2)}MB`);console.log("Screenshots: Quality tiers - HIGH: 60%/200KB, NORMAL: 50%/150KB, PERF: 35%/100KB");console.log(`Rate Limit: ${d.MAX_CAPTURES_PER_SECOND} captures/sec`);console.log("Target: <100ms overlay open, <50MB memory, 60fps");console.log("═══════════════════════════════════════════════════════");
