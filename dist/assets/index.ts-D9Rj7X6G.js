const L="/assets/index.ts-DxkdQ6Si.js";class H{dbName;storeName;db;initPromise;constructor(r,e){this.dbName=r,this.storeName=e,this.db=null,this.initPromise=this._open()}_open(){return new Promise((r,e)=>{const t=indexedDB.open(this.dbName,1);t.onerror=()=>e(t.error),t.onsuccess=()=>{this.db=t.result,r(this.db)},t.onupgradeneeded=a=>{const o=a.target.result;o.objectStoreNames.contains(this.storeName)||o.createObjectStore(this.storeName)}})}async getAll(){return await this.initPromise,new Promise((r,e)=>{const o=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();o.onsuccess=()=>r(o.result),o.onerror=()=>e(o.error)})}async getAllKeys(){return await this.initPromise,new Promise((r,e)=>{if(!this.db){e(new Error("DB not initialized"));return}const o=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAllKeys();o.onsuccess=()=>r(o.result),o.onerror=()=>e(o.error)})}async set(r,e){return await this.initPromise,new Promise((t,a)=>{if(!this.db){a(new Error("DB not initialized"));return}const i=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).put(e,r);i.onsuccess=()=>t(),i.onerror=()=>a(i.error)})}async delete(r){return await this.initPromise,new Promise((e,t)=>{if(!this.db){t(new Error("DB not initialized"));return}const c=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(r);c.onsuccess=()=>e(),c.onerror=()=>t(c.error)})}async clear(){return await this.initPromise,new Promise((r,e)=>{if(!this.db){e(new Error("DB not initialized"));return}const o=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();o.onsuccess=()=>r(),o.onerror=()=>e(o.error)})}}class D{cache;maxTabs;maxBytes;currentBytes;accessOrder;storage;ready;constructor(r=30,e=20*1024*1024){this.cache=new Map,this.maxTabs=r,this.maxBytes=e,this.currentBytes=0,this.accessOrder=[],this.storage=new H("TabSwitcherDB","screenshots"),this.ready=this._restoreFromStorage()}async _restoreFromStorage(){try{const r=await this.storage.getAllKeys();if(r.length===0)return;const e=await this.storage.getAll();r.forEach((t,a)=>{const o=e[a];o&&typeof t=="number"&&o.data&&(this.cache.set(t,o),this.currentBytes+=o.size)}),this.accessOrder=Array.from(this.cache.entries()).sort((t,a)=>a[1].timestamp-t[1].timestamp).map(t=>t[0]),console.log(`[CACHE] Restored ${this.cache.size} screenshots from storage`)}catch(r){console.error("[CACHE] Failed to restore from storage:",r)}}get(r){if(!this.cache.has(r))return null;this.accessOrder=this.accessOrder.filter(t=>t!==r),this.accessOrder.unshift(r);const e=this.cache.get(r);return e.timestamp=Date.now(),this.storage.set(r,e).catch(t=>console.warn("Failed to update timestamp",t)),e}set(r,e){const t=this._estimateSize(e);if(this.cache.has(r)){const o=this.cache.get(r).size;this.currentBytes-=o}for(;(this.cache.size>=this.maxTabs||this.currentBytes+t>this.maxBytes)&&this.cache.size>0;)this._evictLRU();const a={data:e,size:t,timestamp:Date.now()};this.cache.set(r,a),this.currentBytes+=t,this.accessOrder=this.accessOrder.filter(o=>o!==r),this.accessOrder.unshift(r),this.storage.set(r,a).catch(o=>console.error("Failed to persist screenshot",o))}delete(r){if(!this.cache.has(r))return!1;const e=this.cache.get(r);return this.currentBytes-=e.size,this.cache.delete(r),this.accessOrder=this.accessOrder.filter(t=>t!==r),this.storage.delete(r).catch(t=>console.error("Failed to delete screenshot",t)),!0}_evictLRU(){if(this.accessOrder.length===0)return;const r=this.accessOrder.pop(),e=this.cache.get(r);e&&(this.currentBytes-=e.size,this.cache.delete(r),this.storage.delete(r).catch(t=>console.warn("Failed to evict from storage",t)),console.debug(`[LRU] Evicted tab ${r} (${(e.size/1024).toFixed(1)}KB)`))}_estimateSize(r){return Math.ceil(r.length*.75)}getStats(){return{entries:this.cache.size,bytes:this.currentBytes,maxTabs:this.maxTabs,maxBytes:this.maxBytes,utilizationPercent:(this.currentBytes/this.maxBytes*100).toFixed(1)}}clear(){this.cache.clear(),this.accessOrder=[],this.currentBytes=0,this.storage.clear().catch(r=>console.error("Failed to clear storage",r))}}const u={MAX_CACHED_TABS:30,MAX_CACHE_BYTES:20*1024*1024,MAX_SCREENSHOT_SIZE:200*1024,JPEG_QUALITY:60,CAPTURE_DELAY:100,SCREENSHOT_CACHE_DURATION:300*1e3,MAX_CAPTURES_PER_SECOND:2,THROTTLE_INTERVAL:500,PERFORMANCE_LOGGING:!0,QUALITY_TIERS:{HIGH:{quality:80,maxSize:300*1024,label:"High Quality"},NORMAL:{quality:60,maxSize:200*1024,label:"Normal"},PERFORMANCE:{quality:40,maxSize:100*1024,label:"Performance"}},DEFAULT_QUALITY_TIER:"PERFORMANCE"},m=new D(u.MAX_CACHED_TABS,u.MAX_CACHE_BYTES);let g=[];const f=new Map,T=[];let _=0,S=!1,w=null,y=u.DEFAULT_QUALITY_TIER;const p=new Set;let N=!1;const I={overlayOpenTimes:[],captureCount:0,cacheHits:0,cacheMisses:0,recordOverlayOpen(s){this.overlayOpenTimes.push(s),this.overlayOpenTimes.length>100&&this.overlayOpenTimes.shift(),console.log(`[PERF] Overlay open: ${s.toFixed(2)}ms (Target: <100ms)`)},getAverageOverlayTime(){return this.overlayOpenTimes.length===0?0:this.overlayOpenTimes.reduce((r,e)=>r+e,0)/this.overlayOpenTimes.length},logStats(){const s=m.getStats(),r=this.getAverageOverlayTime();console.log("[STATS] ═══════════════════════════════════════"),console.log(`[STATS] Cache: ${s.entries}/${s.maxTabs} tabs`),console.log(`[STATS] Memory: ${(s.bytes/1024/1024).toFixed(2)}MB / ${(s.maxBytes/1024/1024).toFixed(2)}MB (${s.utilizationPercent}%)`),console.log(`[STATS] Captures: ${this.captureCount} (Hits: ${this.cacheHits}, Misses: ${this.cacheMisses})`),console.log(`[STATS] Avg Overlay Open: ${r.toFixed(2)}ms (Target: <100ms)`),console.log("[STATS] ═══════════════════════════════════════")}};function E(s,r=!1){if(T.some(t=>t.tabId===s)||p.has(s))return;const e={tabId:s,timestamp:Date.now()};r?T.unshift(e):T.push(e),z()}async function z(){if(!(S||T.length===0)){for(S=!0;T.length>0;){const r=Date.now()-_;if(r<u.THROTTLE_INTERVAL){const t=u.THROTTLE_INTERVAL-r;await new Promise(a=>setTimeout(a,t))}const e=T.shift();if(e&&e.tabId){p.add(e.tabId);try{await U(e.tabId)}finally{p.delete(e.tabId)}}_=Date.now()}S=!1}}async function U(s,r=null){try{const e=await chrome.tabs.get(s);if(!e.active)return console.debug(`[CAPTURE] Tab ${s} is not active, skipping capture`),null;if(!x(e))return console.debug(`[CAPTURE] Tab ${s} not capturable: ${e.url}`),null;await new Promise(h=>setTimeout(h,u.CAPTURE_DELAY+50));const t=await chrome.tabs.get(s).catch(()=>null);if(!t||!t.active)return console.debug(`[CAPTURE] Tab ${s} no longer active after delay`),null;const a=r||y,o=u.QUALITY_TIERS[a]||u.QUALITY_TIERS.NORMAL,c=performance.now();let i=null;try{i=await chrome.tabs.captureVisibleTab(e.windowId,{format:"jpeg",quality:o.quality})}catch{console.debug("[CAPTURE] First attempt failed, retrying with lower quality");try{await new Promise(n=>setTimeout(n,100)),i=await chrome.tabs.captureVisibleTab(e.windowId,{format:"jpeg",quality:Math.max(30,o.quality-20)})}catch(n){return console.debug(`[CAPTURE] Retry also failed for tab ${s}:`,n.message),null}}if(!i)return console.debug(`[CAPTURE] No screenshot data for tab ${s}`),null;const l=performance.now()-c,d=m._estimateSize(i);return d>o.maxSize*1.5&&console.warn(`[CAPTURE] Screenshot large: ${(d/1024).toFixed(1)}KB (target: ${(o.maxSize/1024).toFixed(1)}KB)`),m.set(s,i),I.captureCount++,u.PERFORMANCE_LOGGING&&console.debug(`[CAPTURE] Tab ${s}: ${l.toFixed(2)}ms, ${(d/1024).toFixed(1)}KB (${o.label})`),i}catch(e){return console.debug(`[CAPTURE] Failed for tab ${s}:`,e.message),null}}function x(s){if(s.discarded||!s.url)return!1;const r=["chrome://","edge://","devtools://","view-source:"];return!(s.url&&r.some(e=>s.url.startsWith(e)))}typeof chrome<"u"&&chrome.tabs?(chrome.tabs.onActivated.addListener(async s=>{try{w=s.tabId,v=Date.now(),k(s.tabId),setTimeout(()=>{E(s.tabId,!0)},200)}catch(r){console.debug("[TAB] Error in onActivated:",r)}}),chrome.tabs.onUpdated.addListener((s,r,e)=>{try{r.status==="complete"&&e.active&&setTimeout(()=>{E(s,!0)},300)}catch(t){console.debug("[TAB] Error in onUpdated:",t)}}),chrome.tabs.onCreated.addListener(s=>{try{s.id&&f.set(s.id,Date.now())}catch(r){console.debug("[TAB] Error in onCreated:",r)}}),chrome.tabs.onRemoved.addListener(s=>{try{m.delete(s),M(s),f.delete(s),p.delete(s),console.debug(`[CLEANUP] Removed tab ${s} from cache`)}catch(r){console.debug("[TAB] Error in onRemoved:",r)}})):console.error("[INIT] chrome.tabs API not available");let v=Date.now();setInterval(async()=>{try{if(!w)return;const s=300*1e3;Date.now()-v>s&&(console.debug(`[IDLE] Tab ${w} idle > 5m, refreshing screenshot`),v=Date.now(),E(w,!0))}catch(s){console.debug("[IDLE] Error in idle check:",s)}},60*1e3);function k(s){M(s),g.unshift(s),g.length>u.MAX_CACHED_TABS*2&&(g.length=u.MAX_CACHED_TABS*2),$()}function M(s){const r=g.indexOf(s);r!==-1&&g.splice(r,1)}let O=null;function $(){O&&clearTimeout(O),O=setTimeout(()=>{chrome.storage.local.set({recentTabOrder:g.slice(0,100)}).catch(s=>console.debug("[STORAGE] Failed to save recent order:",s))},500)}async function F(){try{const s=await chrome.storage.local.get(["recentTabOrder"]);if(s.recentTabOrder&&Array.isArray(s.recentTabOrder)){const r=await chrome.tabs.query({}),e=new Set(r.map(t=>t.id));g=s.recentTabOrder.filter(t=>e.has(t)),console.log(`[INIT] Restored ${g.length} recent tab order entries`)}}catch(s){console.debug("[STORAGE] Failed to restore recent order:",s)}N=!0}typeof chrome<"u"&&chrome.commands&&chrome.commands.onCommand.addListener(s=>{(s==="show-tab-switcher"||s==="cycle-next-tab")&&P()});async function P(){m.ready&&await m.ready,N||await F();const s=performance.now();try{const r=await chrome.windows.getCurrent(),e=await chrome.tabs.query({windowId:r.id});let t=[];if(chrome.tabGroups)try{t=await chrome.tabGroups.query({windowId:r.id})}catch(n){console.debug("[GROUPS] Failed to fetch groups:",n)}const a=Date.now();e.forEach((n,R)=>{f.has(n.id)||f.set(n.id,a-(e.length-R)*1e3)});const o=G(e),c=8,i=o.map((n,R)=>{let A=null;const B=R<c;if(x(n)&&B){const C=m.get(n.id);C?(A=C,I.cacheHits++):I.cacheMisses++}return{id:n.id,title:n.title||"Untitled",url:n.url,favIconUrl:n.favIconUrl,screenshot:A?A.data:null,pinned:n.pinned,index:n.index,active:n.active,audible:n.audible,mutedInfo:n.mutedInfo,groupId:n.groupId}}),l=t.map(n=>({id:n.id,title:n.title,color:n.color,collapsed:n.collapsed})),[d]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!x(d)){console.warn("[INJECT] Cannot open overlay on protected page. Switch to a regular webpage and try again.");return}await Y(d.id,{action:"showTabSwitcher",tabs:i,groups:l,activeTabId:d.id});const h=performance.now()-s;I.recordOverlayOpen(h)}catch(r){console.error("[ERROR] Failed to show tab switcher:",r)}}async function Y(s,r,e=1){try{await chrome.tabs.sendMessage(s,r)}catch(t){if(e>0&&t.message&&t.message.includes("Could not establish connection")){console.log("[INJECT] Content script not ready, injecting...");try{await chrome.scripting.executeScript({target:{tabId:s},files:[L]}),await new Promise(a=>setTimeout(a,150)),await chrome.tabs.sendMessage(s,r)}catch(a){const o=a&&a.message?a.message:"";if(o.includes("cannot be scripted")||o.includes("Cannot access a chrome://")||o.includes("Cannot access a chrome-extension://")||o.includes("Cannot access")&&o.includes("URL"))console.warn("[INJECT] Cannot inject on this page (protected URL). Try on a regular webpage.");else throw a}}else throw t}}function G(s){return[...s].sort((r,e)=>{const t=r.id?g.indexOf(r.id):-1,a=e.id?g.indexOf(e.id):-1;if(t!==-1&&a!==-1)return t-a;if(t!==-1)return-1;if(a!==-1)return 1;const o=f.get(r.id)||0,c=f.get(e.id)||0;return o!==c?c-o:e.index-r.index})}class Q{storage;constructor(){this.storage=chrome.storage.local,this.init()}init(){chrome.webNavigation&&(chrome.webNavigation.onCommitted.addListener(this.onNavigation.bind(this)),chrome.webNavigation.onHistoryStateUpdated&&chrome.webNavigation.onHistoryStateUpdated.addListener(this.onNavigation.bind(this)),chrome.webNavigation.onReferenceFragmentUpdated&&chrome.webNavigation.onReferenceFragmentUpdated.addListener(this.onNavigation.bind(this))),chrome.tabs.onUpdated.addListener(this.onTabUpdated.bind(this)),chrome.tabs.onRemoved.addListener(this.onTabRemoved.bind(this)),this.initializeAllTabs()}async initializeAllTabs(){try{const r=await chrome.tabs.query({});console.log("[HISTORY] Initializing",r.length,"existing tabs");for(const e of r)e.url&&!e.url.startsWith("chrome://")&&!e.url.startsWith("edge://")&&e.id&&await this.initializeTab(e.id,e.url,e.title)}catch(r){console.error("[HISTORY] Error initializing tabs:",r)}}async initializeTab(r,e,t=""){if(!e||e.startsWith("chrome://")||e.startsWith("edge://"))return;const a=`hist_${r}`;try{if(!(await this.storage.get(a))[a]){const i={stack:[{url:e,title:t||e}],currentIndex:0};await this.storage.set({[a]:i}),console.log("[HISTORY] Initialized tab",r,"with:",t||e.substring(0,50))}}catch(o){console.debug("[HISTORY] Error initializing tab:",r,o)}}async onTabUpdated(r,e,t){e.status==="complete"&&t.url&&(await this.initializeTab(r,t.url,t.title||""),await this.updateCurrentTitle(r,t.url,t.title||"")),e.title&&t.url&&await this.updateCurrentTitle(r,t.url,e.title)}async onNavigation(r){if(r.frameId!==0)return;const e=r.tabId,t=r.url,a=r.transitionQualifiers||[];if(a.includes("reload"))return;const o=a.includes("forward_back");try{const c=await chrome.tabs.get(e);await this.addToHistory(e,t,c.title||"",o)}catch{await this.addToHistory(e,t,"",o)}}async updateCurrentTitle(r,e,t){const a=`hist_${r}`;try{const c=(await this.storage.get(a))[a];if(!c||c.currentIndex<0)return;const i=c.stack[c.currentIndex];i&&(typeof i=="string"?i:i.url)===e&&(c.stack[c.currentIndex]={url:e,title:t},await this.storage.set({[a]:c}))}catch{}}getEntryUrl(r){if(r)return typeof r=="string"?r:r.url}async addToHistory(r,e,t,a){if(!e||e.startsWith("chrome://")||e.startsWith("edge://")||e.startsWith("devtools://"))return;const o=`hist_${r}`;try{let i=(await this.storage.get(o))[o]||{stack:[],currentIndex:-1};const l={url:e,title:t||e},d=(h,n)=>this.getEntryUrl(h)===n;if(i.currentIndex>=0&&i.currentIndex<i.stack.length&&d(i.stack[i.currentIndex],e)){t&&(i.stack[i.currentIndex]=l,await this.storage.set({[o]:i}));return}if(a){let h=-1;for(let n=i.currentIndex-1;n>=0;n--)if(d(i.stack[n],e)){h=n;break}if(h===-1){for(let n=i.currentIndex+1;n<i.stack.length;n++)if(d(i.stack[n],e)){h=n;break}}h!==-1?(i.currentIndex=h,t&&(i.stack[h]=l)):(i.currentIndex>=0&&i.currentIndex<i.stack.length-1&&(i.stack=i.stack.slice(0,i.currentIndex+1)),i.stack.push(l),i.currentIndex=i.stack.length-1)}else i.currentIndex>=0&&i.currentIndex<i.stack.length-1&&(i.stack=i.stack.slice(0,i.currentIndex+1)),(i.currentIndex>=0?this.getEntryUrl(i.stack[i.currentIndex]):null)!==e?(i.stack.push(l),i.currentIndex=i.stack.length-1):t&&i.currentIndex>=0&&(i.stack[i.currentIndex]=l);if(i.stack.length>50){const h=i.stack.length-50;i.stack.splice(0,h),i.currentIndex=Math.max(0,i.currentIndex-h)}await this.storage.set({[o]:i}),console.log("[HISTORY] Updated tab",r,"- stack:",i.stack.length,"items, index:",i.currentIndex)}catch(c){console.error("[HISTORY] Error updating history:",c)}}async onTabRemoved(r){try{await this.storage.remove(`hist_${r}`)}catch{console.debug("[HISTORY] Failed to remove history for tab:",r)}}async getHistory(r){try{const e=`hist_${r}`,a=(await this.storage.get(e))[e];if(console.log("[HISTORY] Getting history for tab",r,"data:",a),!a||!a.stack||a.stack.length===0)return{back:[],forward:[]};const o=l=>typeof l=="string"?{url:l,title:l}:{url:l.url,title:l.title||l.url},c=a.currentIndex>0?a.stack.slice(0,a.currentIndex).reverse().map(o):[],i=a.currentIndex<a.stack.length-1?a.stack.slice(a.currentIndex+1).map(o):[];return console.log("[HISTORY] Returning - back:",c.length,"forward:",i.length),{back:c,forward:i}}catch(e){return console.error("[HISTORY] Error getting history:",e),{back:[],forward:[]}}}async updateIndexByDelta(r,e){const t=`hist_${r}`;try{const o=(await this.storage.get(t))[t];if(!o||!o.stack)return!1;const c=o.currentIndex+e;return c<0||c>=o.stack.length?!1:(o.currentIndex=c,await this.storage.set({[t]:o}),console.log("[HISTORY] Updated currentIndex to",c,"for tab",r),!0)}catch(a){return console.error("[HISTORY] Error updating index by delta:",a),!1}}async navigate(r,e){r&&(await this.updateIndexByDelta(r,e),chrome.scripting.executeScript({target:{tabId:r},func:t=>window.history.go(t),args:[e]}))}}const b=new Q;typeof chrome<"u"&&chrome.runtime&&chrome.runtime.onMessage&&chrome.runtime.onMessage.addListener((s,r,e)=>(W(s,r,e),!0));async function W(s,r,e){try{if(!s||!s.action){console.error("[ERROR] Invalid message received:",s),e({success:!1,error:"Invalid message format"});return}switch(s.action){case"getRecentlyClosed":try{const a=Math.min(25,typeof s.maxResults=="number"?s.maxResults:10),o=await chrome.sessions.getRecentlyClosed({maxResults:25}),c=[];for(const l of o)if(l.tab)c.push({kind:"tab",sessionId:l.tab.sessionId,lastModified:l.lastModified,title:l.tab.title||"Untitled",url:l.tab.url||"",favIconUrl:l.tab.favIconUrl||""});else if(l.window&&Array.isArray(l.window.tabs))for(const d of l.window.tabs)c.push({kind:"tab",sessionId:d.sessionId||l.window.sessionId,lastModified:l.lastModified,title:d.title||"Untitled",url:d.url||"",favIconUrl:d.favIconUrl||""});else l.window&&l.window.sessionId&&c.push({kind:"window",sessionId:l.window.sessionId,lastModified:l.lastModified,title:"Window",url:"",favIconUrl:""});c.sort((l,d)=>(d.lastModified||0)-(l.lastModified||0));const i=c.slice(0,a);e({success:!0,items:i})}catch(t){console.error("[ERROR] Failed to get recently closed:",t),e({success:!1,error:t.message})}break;case"restoreSession":try{if(!s.sessionId||typeof s.sessionId!="string"){e({success:!1,error:"Invalid sessionId"});return}const t=await chrome.sessions.restore(s.sessionId);e({success:!0,restored:t})}catch(t){console.error("[ERROR] Failed to restore session:",t),e({success:!1,error:t.message})}break;case"switchToTab":if(!s.tabId||typeof s.tabId!="number"){e({success:!1,error:"Invalid tab ID"});return}try{await chrome.tabs.update(s.tabId,{active:!0}),e({success:!0})}catch(t){console.error("[ERROR] Failed to switch to tab:",t),e({success:!1,error:t.message})}break;case"closeTab":if(!s.tabId||typeof s.tabId!="number"){e({success:!1,error:"Invalid tab ID"});return}try{if(!await chrome.tabs.get(s.tabId).catch(()=>null)){console.warn("[WARNING] Tab no longer exists:",s.tabId),e({success:!1,error:"Tab no longer exists"});return}await chrome.tabs.remove(s.tabId),e({success:!0})}catch(t){console.error("[ERROR] Failed to close tab:",t),e({success:!1,error:t.message})}break;case"toggleMute":if(!s.tabId||typeof s.tabId!="number"){e({success:!1,error:"Invalid tab ID"});return}try{const a=!(await chrome.tabs.get(s.tabId)).mutedInfo.muted;await chrome.tabs.update(s.tabId,{muted:a}),e({success:!0,muted:a})}catch(t){console.error("[ERROR] Failed to toggle mute:",t),e({success:!1,error:t.message})}break;case"refreshTabList":try{await P(),e({success:!0})}catch(t){console.error("[ERROR] Failed to refresh tab list:",t),e({success:!1,error:t.message})}break;case"captureTabScreenshot":if(!s.tabId||typeof s.tabId!="number"){e({success:!1,error:"Invalid tab ID"});return}try{const t=await U(s.tabId,null);e({success:!!t,screenshot:t})}catch(t){console.error("[ERROR] Failed to capture screenshot:",t),e({success:!1,error:t.message})}break;case"getCacheStats":try{const t=m.getStats();e({success:!0,stats:t})}catch(t){console.error("[ERROR] Failed to get cache stats:",t),e({success:!1,error:t.message})}break;case"setQualityTier":try{const t=s.tier||u.DEFAULT_QUALITY_TIER;u.QUALITY_TIERS[t]?(y=t,chrome.storage.local.set({qualityTier:t}),console.log(`[SETTINGS] Quality tier changed to: ${t}`),e({success:!0,tier:t})):e({success:!1,error:"Invalid quality tier"})}catch(t){console.error("[ERROR] Failed to set quality tier:",t),e({success:!1,error:t.message})}break;case"GET_TAB_HISTORY":try{const t=r.tab?r.tab.id:s.tabId;if(!t){e({back:[],forward:[]});return}const a=await b.getHistory(t);console.log("[HISTORY] Sending history for tab",t,a),e(a)}catch(t){console.error("[ERROR] Failed to get tab history:",t),e({back:[],forward:[]})}break;case"REPORT_NAVIGATION":try{const t=r.tab?r.tab.id:s.tabId,a=typeof s.url=="string"?s.url:"",o=typeof s.title=="string"?s.title:"",c=typeof s.navType=="string"?s.navType:"navigate";if(!t||!a){e({success:!1,error:"Missing tabId or url"});return}if(c==="title_update"){await b.updateCurrentTitle(t,a,o),e({success:!0,type:"title_update"});return}if(c==="reload"){await b.initializeTab(t,a,o),await b.updateCurrentTitle(t,a,o),e({success:!0,ignored:"reload"});return}const i=c==="back_forward";await b.addToHistory(t,a,o,i),e({success:!0})}catch(t){console.error("[ERROR] Failed to report navigation:",t),e({success:!1,error:t.message})}break;case"NAVIGATE_HISTORY":try{const t=r.tab?r.tab.id:s.tabId;t&&typeof s.delta=="number"?(await b.navigate(t,s.delta),e({success:!0})):e({success:!1,error:"Invalid tabId or delta"})}catch(t){console.error("[ERROR] Failed to navigate history:",t),e({success:!1,error:t.message})}break;case"createGroup":try{if(s.tabId&&chrome.tabs.group){const t=await chrome.tabs.group({tabIds:s.tabId});e({success:!0,groupId:t})}else e({success:!1,error:"Missing tabId or API not supported"})}catch(t){console.error("[GROUPS] Failed to create group:",t),e({success:!1,error:t.message})}break;default:console.warn("[WARNING] Unknown action:",s.action),e({success:!1,error:"Unknown action"})}}catch(t){console.error("[ERROR] Message handler failed:",t),e({success:!1,error:t.message})}}setInterval(()=>{I.logStats()},6e4);async function X(){try{await F();const s=await chrome.tabs.query({}),r=Date.now();s.forEach((t,a)=>{t.id&&!f.has(t.id)&&f.set(t.id,r-(s.length-a)*1e3)});const e=await chrome.windows.getAll();for(const t of e){const[a]=await chrome.tabs.query({windowId:t.id,active:!0});a&&a.id&&(g.indexOf(a.id)===-1&&k(a.id),w=a.id,setTimeout(()=>{a.id&&E(a.id,!0)},500))}console.log(`[INIT] Initialized ${s.length} existing tabs, ${g.length} in recent order`)}catch(s){console.error("[INIT] Failed to initialize existing tabs:",s)}}console.log("[INIT] Visual Tab Switcher initialized");chrome.storage.local.get(["qualityTier"],s=>{try{const r=s&&s.qualityTier,e=u&&u.QUALITY_TIERS;r&&e&&e[r]?(y=r,console.log(`[INIT] Loaded quality tier: ${y}`)):console.log("[INIT] Using default quality tier:",y)}catch(r){console.warn("[INIT] Failed to load quality tier, using default:",r&&r.message?r.message:r)}});setTimeout(X,100);console.log("═══════════════════════════════════════════════════════");console.log("Visual Tab Switcher - Performance Optimized");console.log("═══════════════════════════════════════════════════════");console.log(`Cache: Max ${u.MAX_CACHED_TABS} tabs, ${(u.MAX_CACHE_BYTES/1024/1024).toFixed(2)}MB`);console.log("Screenshots: Quality tiers - HIGH: 60%/200KB, NORMAL: 50%/150KB, PERF: 35%/100KB");console.log(`Rate Limit: ${u.MAX_CAPTURES_PER_SECOND} captures/sec`);console.log("Target: <100ms overlay open, <50MB memory, 60fps");console.log("═══════════════════════════════════════════════════════");
