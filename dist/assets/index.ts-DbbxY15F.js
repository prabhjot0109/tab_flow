const h={MAX_CACHED_TABS:30,MAX_CACHE_BYTES:20971520,MAX_SCREENSHOT_SIZE:204800,JPEG_QUALITY:60,CAPTURE_DELAY:100,SCREENSHOT_CACHE_DURATION:3e5,MAX_CAPTURES_PER_SECOND:2,THROTTLE_INTERVAL:500,PERFORMANCE_LOGGING:!0,QUALITY_TIERS:{HIGH:{quality:80,maxSize:307200,label:"High Quality"},NORMAL:{quality:60,maxSize:204800,label:"Normal"},PERFORMANCE:{quality:40,maxSize:102400,label:"Performance"}},DEFAULT_QUALITY_TIER:"PERFORMANCE",ALARMS:{IDLE_CHECK:"idle-screenshot-check",PERF_LOG:"performance-log"}};class X{dbName;storeName;db;initPromise;constructor(t,r){this.dbName=t,this.storeName=r,this.db=null,this.initPromise=this._open()}_open(){return new Promise((t,r)=>{const o=indexedDB.open(this.dbName,1);o.onerror=()=>r(o.error),o.onsuccess=()=>{this.db=o.result,t(this.db)},o.onupgradeneeded=a=>{const s=a.target.result;s.objectStoreNames.contains(this.storeName)||s.createObjectStore(this.storeName)}})}async getAll(){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((t,r)=>{const s=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();s.onsuccess=()=>t(s.result),s.onerror=()=>r(s.error)})}async getAllKeys(){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((t,r)=>{const s=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAllKeys();s.onsuccess=()=>t(s.result),s.onerror=()=>r(s.error)})}async set(t,r){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((o,a)=>{const u=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).put(r,t);u.onsuccess=()=>o(),u.onerror=()=>a(u.error)})}async delete(t){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((r,o)=>{const c=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(t);c.onsuccess=()=>r(),c.onerror=()=>o(c.error)})}async clear(){if(await this.initPromise,!this.db)throw new Error("DB not initialized");return new Promise((t,r)=>{const s=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();s.onsuccess=()=>t(),s.onerror=()=>r(s.error)})}}class K{cache;maxTabs;maxBytes;currentBytes;accessOrder;storage;ready;constructor(t=30,r=20*1024*1024){this.cache=new Map,this.maxTabs=t,this.maxBytes=r,this.currentBytes=0,this.accessOrder=[],this.storage=new X("TabFlowDB","screenshots"),this.ready=this._restoreFromStorage()}async _restoreFromStorage(){try{const t=await this.storage.getAllKeys();if(t.length===0)return;const r=await this.storage.getAll();t.forEach((o,a)=>{const s=r[a];if(typeof o!="number"||!s||typeof s!="object")return;const c=s;typeof c.data=="string"&&typeof c.size=="number"&&typeof c.timestamp=="number"&&(this.cache.set(o,c),this.currentBytes+=c.size)}),this.accessOrder=Array.from(this.cache.entries()).sort((o,a)=>a[1].timestamp-o[1].timestamp).map(o=>o[0]),console.log(`[CACHE] Restored ${this.cache.size} screenshots from storage`)}catch(t){console.error("[CACHE] Failed to restore from storage:",t)}}get(t){if(!this.cache.has(t))return null;this.accessOrder=this.accessOrder.filter(o=>o!==t),this.accessOrder.unshift(t);const r=this.cache.get(t);return r.timestamp=Date.now(),this.storage.set(t,r).catch(o=>console.warn("Failed to update timestamp",o)),r}set(t,r){const o=this._estimateSize(r);if(this.cache.has(t)){const s=this.cache.get(t).size;this.currentBytes-=s}for(;(this.cache.size>=this.maxTabs||this.currentBytes+o>this.maxBytes)&&this.cache.size>0;)this._evictLRU();const a={data:r,size:o,timestamp:Date.now()};this.cache.set(t,a),this.currentBytes+=o,this.accessOrder=this.accessOrder.filter(s=>s!==t),this.accessOrder.unshift(t),this.storage.set(t,a).catch(s=>console.error("Failed to persist screenshot",s))}delete(t){if(!this.cache.has(t))return!1;const r=this.cache.get(t);return r?(this.currentBytes-=r.size,this.cache.delete(t),this.accessOrder=this.accessOrder.filter(o=>o!==t),this.storage.delete(t).catch(o=>console.error("Failed to delete screenshot",o)),!0):!1}_evictLRU(){if(this.accessOrder.length===0)return;const t=this.accessOrder.pop();if(t===void 0)return;const r=this.cache.get(t);r&&(this.currentBytes-=r.size,this.cache.delete(t),this.storage.delete(t).catch(o=>console.warn("Failed to evict from storage",o)),console.debug(`[LRU] Evicted tab ${t} (${(r.size/1024).toFixed(1)}KB)`))}_estimateSize(t){return Math.ceil(t.length*.75)}getStats(){return{entries:this.cache.size,bytes:this.currentBytes,maxTabs:this.maxTabs,maxBytes:this.maxBytes,utilizationPercent:(this.currentBytes/this.maxBytes*100).toFixed(1)}}clear(){this.cache.clear(),this.accessOrder=[],this.currentBytes=0,this.storage.clear().catch(t=>console.error("Failed to clear storage",t))}}const A={overlayOpenTimes:[],captureCount:0,cacheHits:0,cacheMisses:0,recordOverlayOpen(e){this.overlayOpenTimes.push(e),this.overlayOpenTimes.length>100&&this.overlayOpenTimes.shift(),console.log(`[PERF] Overlay open: ${e.toFixed(2)}ms (Target: <100ms)`)},getAverageOverlayTime(){return this.overlayOpenTimes.length===0?0:this.overlayOpenTimes.reduce((t,r)=>t+r,0)/this.overlayOpenTimes.length},logStats(e){const t=e.getStats(),r=this.getAverageOverlayTime();console.log("[STATS] ═══════════════════════════════════════"),console.log(`[STATS] Cache: ${t.entries}/${t.maxTabs} tabs`),console.log(`[STATS] Memory: ${(t.bytes/1024/1024).toFixed(2)}MB / ${(t.maxBytes/1024/1024).toFixed(2)}MB (${t.utilizationPercent}%)`),console.log(`[STATS] Captures: ${this.captureCount} (Hits: ${this.cacheHits}, Misses: ${this.cacheMisses})`),console.log(`[STATS] Avg Overlay Open: ${r.toFixed(2)}ms (Target: <100ms)`),console.log("[STATS] ═══════════════════════════════════════")}},g=new Set;function x(){try{chrome.storage.session.set({tabsWithMedia:Array.from(g)})}catch{}}async function q(){try{const e=await chrome.storage.session.get("tabsWithMedia");e.tabsWithMedia&&Array.isArray(e.tabsWithMedia)&&e.tabsWithMedia.forEach(t=>g.add(t))}catch{}}function U(e){return g.has(e)}function D(e){g.has(e)||(g.add(e),x(),console.debug(`[MEDIA] Tab ${e} marked as having media`))}function V(e){g.has(e)&&(g.delete(e),x())}async function J(){try{const e=await chrome.tabs.query({audible:!0});for(const r of e)r.id&&!g.has(r.id)&&g.add(r.id);const t=await chrome.tabs.query({});for(const r of t)r.id&&r.mutedInfo?.muted&&!g.has(r.id)&&g.add(r.id);g.size>0&&(x(),console.log(`[MEDIA] Initialized ${g.size} tabs with media`))}catch(e){console.debug("[MEDIA] Error initializing audible tabs:",e)}}let b=[];const p=new Map;let _=null,B=Date.now(),z=!1,P=null;function Z(e){return p.get(e)}function ee(){return _}function te(){return B}function re(){return z}function se(e){_=e}function $(){B=Date.now()}function W(e,t){p.set(e,t??Date.now())}function H(e){G(e),b.unshift(e),b.length>h.MAX_CACHED_TABS*2&&(b.length=h.MAX_CACHED_TABS*2),ae()}function G(e){const t=b.indexOf(e);t!==-1&&b.splice(t,1)}function oe(e){p.delete(e)}function ae(){P&&clearTimeout(P),P=setTimeout(()=>{chrome.storage.local.set({recentTabOrder:b.slice(0,100)}).catch(e=>console.debug("[STORAGE] Failed to save recent order:",e))},500)}async function Q(){try{const e=await chrome.storage.local.get(["recentTabOrder"]);if(e.recentTabOrder&&Array.isArray(e.recentTabOrder)){const t=await chrome.tabs.query({}),r=new Set(t.map(o=>o.id));b=e.recentTabOrder.filter(o=>r.has(o)),console.log(`[INIT] Restored ${b.length} recent tab order entries`)}}catch(e){console.debug("[STORAGE] Failed to restore recent order:",e)}z=!0}function Y(e){return[...e].sort((t,r)=>{const o=t.lastAccessed||0,a=r.lastAccessed||0;if(o&&a)return a-o;if(o)return-1;if(a)return 1;const s=typeof t.id=="number"?b.indexOf(t.id):-1,c=typeof r.id=="number"?b.indexOf(r.id):-1;if(s!==-1&&c!==-1)return s-c;if(s!==-1)return-1;if(c!==-1)return 1;const u=typeof t.id=="number"?p.get(t.id)??0:0,d=typeof r.id=="number"?p.get(r.id)??0:0;return u!==d?d-u:(r.index??0)-(t.index??0)})}async function ie(){try{await Q();const e=await chrome.tabs.query({}),t=Date.now();e.forEach((o,a)=>{o.id&&!p.has(o.id)&&p.set(o.id,t-(e.length-a)*1e3)});const r=await chrome.windows.getAll();for(const o of r){const[a]=await chrome.tabs.query({windowId:o.id,active:!0});a&&a.id&&(b.indexOf(a.id)===-1&&H(a.id),_=a.id)}console.log(`[INIT] Initialized ${e.length} existing tabs, ${b.length} in recent order`)}catch(e){console.error("[INIT] Failed to initialize existing tabs:",e)}}const I=[];let N=0,F=!1;const C=new Set;let R=h.DEFAULT_QUALITY_TIER;function ce(e){return h.QUALITY_TIERS[e]?(R=e,!0):!1}async function ne(){try{const t=(await chrome.storage.local.get(["qualityTier"]))?.qualityTier;t&&h.QUALITY_TIERS[t]?(R=t,console.log(`[INIT] Loaded quality tier: ${R}`)):console.log("[INIT] Using default quality tier:",R)}catch(e){const t=e instanceof Error?e.message:typeof e=="string"?e:String(e);console.warn("[INIT] Failed to load quality tier, using default:",t)}}function M(e,t,r=!1){if(I.some(a=>a.tabId===e)||C.has(e))return;const o={tabId:e,timestamp:Date.now()};r?I.unshift(o):I.push(o),le(t)}async function le(e){if(!(F||I.length===0)){for(F=!0;I.length>0;){const r=Date.now()-N;if(r<h.THROTTLE_INTERVAL){const a=h.THROTTLE_INTERVAL-r;await new Promise(s=>setTimeout(s,a))}const o=I.shift();if(o&&o.tabId){C.add(o.tabId);try{await k(o.tabId,e)}finally{C.delete(o.tabId)}}N=Date.now()}F=!1}}async function k(e,t,r=null){try{const o=await chrome.tabs.get(e);if(!o.active)return console.debug(`[CAPTURE] Tab ${e} is not active, skipping capture`),null;if(!v(o))return console.debug(`[CAPTURE] Tab ${e} not capturable: ${o.url}`),null;await new Promise(f=>setTimeout(f,h.CAPTURE_DELAY+50));const a=await chrome.tabs.get(e).catch(()=>null);if(!a||!a.active)return console.debug(`[CAPTURE] Tab ${e} no longer active after delay`),null;const s=r||R,c=h.QUALITY_TIERS[s]||h.QUALITY_TIERS.NORMAL,u=performance.now();let d=null;try{d=await chrome.tabs.captureVisibleTab(o.windowId,{format:"jpeg",quality:c.quality})}catch{console.debug("[CAPTURE] First attempt failed, retrying with lower quality");try{await new Promise(i=>setTimeout(i,100)),d=await chrome.tabs.captureVisibleTab(o.windowId,{format:"jpeg",quality:Math.max(30,c.quality-20)})}catch(i){const l=i instanceof Error?i.message:String(i);return console.debug(`[CAPTURE] Retry also failed for tab ${e}:`,l),null}}if(!d)return console.debug(`[CAPTURE] No screenshot data for tab ${e}`),null;const m=performance.now()-u,n=t._estimateSize(d);return n>c.maxSize*1.5&&console.warn(`[CAPTURE] Screenshot large: ${(n/1024).toFixed(1)}KB (target: ${(c.maxSize/1024).toFixed(1)}KB)`),t.set(e,d),A.captureCount++,h.PERFORMANCE_LOGGING&&console.debug(`[CAPTURE] Tab ${e}: ${m.toFixed(2)}ms, ${(n/1024).toFixed(1)}KB (${c.label})`),d}catch(o){const a=o instanceof Error?o.message:String(o);return console.debug(`[CAPTURE] Failed for tab ${e}:`,a),null}}function v(e){if(e.discarded||!e.url)return!1;const t=["chrome://","edge://","devtools://","view-source:"];return!(e.url&&t.some(r=>e.url.startsWith(r)))}function de(e){C.delete(e)}const ue="/assets/index.ts-loader-CTQ9uiuU.js";async function he(e,t,r,o,a){try{if(!e||!e.action){console.error("[ERROR] Invalid message received:",e),r({success:!1,error:"Invalid message format"});return}switch(e.action){case"FlowPopupCycleNext":r({success:!0});break;case"reportMediaPresence":t.tab&&t.tab.id&&D(t.tab.id),r({success:!0});break;case"getRecentlyClosed":try{const c=Math.min(25,typeof e.maxResults=="number"?e.maxResults:10),u=await chrome.sessions.getRecentlyClosed({maxResults:25}),d=[];for(const n of u)if(n.tab)d.push({kind:"tab",sessionId:n.tab.sessionId,lastModified:n.lastModified,title:n.tab.title||"Untitled",url:n.tab.url||"",favIconUrl:n.tab.favIconUrl||""});else if(n.window&&Array.isArray(n.window.tabs))for(const f of n.window.tabs)d.push({kind:"tab",sessionId:f.sessionId||n.window.sessionId,lastModified:n.lastModified,title:f.title||"Untitled",url:f.url||"",favIconUrl:f.favIconUrl||""});else n.window&&n.window.sessionId&&d.push({kind:"window",sessionId:n.window.sessionId,lastModified:n.lastModified,title:"Window",url:"",favIconUrl:""});d.sort((n,f)=>(f.lastModified||0)-(n.lastModified||0));const m=d.slice(0,c);r({success:!0,items:m})}catch(s){console.error("[ERROR] Failed to get recently closed:",s),r({success:!1,error:s.message})}break;case"restoreSession":try{if(!e.sessionId||typeof e.sessionId!="string"){r({success:!1,error:"Invalid sessionId"});return}const s=await chrome.sessions.restore(e.sessionId);r({success:!0,restored:s})}catch(s){console.error("[ERROR] Failed to restore session:",s),r({success:!1,error:s.message})}break;case"switchToTab":if(!e.tabId||typeof e.tabId!="number"){r({success:!1,error:"Invalid tab ID"});return}try{await chrome.tabs.update(e.tabId,{active:!0}),r({success:!0})}catch(s){console.error("[ERROR] Failed to switch to tab:",s),r({success:!1,error:s.message})}break;case"closeTab":if(!e.tabId||typeof e.tabId!="number"){r({success:!1,error:"Invalid tab ID"});return}try{if(!await chrome.tabs.get(e.tabId).catch(()=>null)){console.warn("[WARNING] Tab no longer exists:",e.tabId),r({success:!1,error:"Tab no longer exists"});return}await chrome.tabs.remove(e.tabId),r({success:!0})}catch(s){console.error("[ERROR] Failed to close tab:",s),r({success:!1,error:s.message})}break;case"toggleMute":if(!e.tabId||typeof e.tabId!="number"){r({success:!1,error:"Invalid tab ID"});return}try{const c=!((await chrome.tabs.get(e.tabId)).mutedInfo?.muted??!1);await chrome.tabs.update(e.tabId,{muted:c}),r({success:!0,muted:c})}catch(s){console.error("[ERROR] Failed to toggle mute:",s),r({success:!1,error:s.message})}break;case"togglePlayPause":if(!e.tabId||typeof e.tabId!="number"){r({success:!1,error:"Invalid tab ID"});return}try{const s=await chrome.tabs.get(e.tabId);if(v(s)){const c=await chrome.scripting.executeScript({target:{tabId:e.tabId},func:()=>{const u=[...document.querySelectorAll("video, audio")];return u.length===0?{success:!1,reason:"no_media"}:u.some(m=>!m.paused&&!m.ended)?(u.forEach(m=>m.pause()),{success:!0,playing:!1}):(u.forEach(m=>m.play().catch(()=>{})),{success:!0,playing:!0})}});c&&c[0]?r({success:!0,...c[0].result}):r({success:!1,error:"Script execution failed"})}else r({success:!1,error:"Cannot script in this tab"})}catch(s){console.error("[ERROR] Failed to toggle play/pause:",s),r({success:!1,error:s.message})}break;case"refreshTabList":try{await a(),r({success:!0})}catch(s){console.error("[ERROR] Failed to refresh tab list:",s),r({success:!1,error:s.message})}break;case"captureTabScreenshot":if(!e.tabId||typeof e.tabId!="number"){r({success:!1,error:"Invalid tab ID"});return}try{const s=await k(e.tabId,o);r({success:!!s,screenshot:s})}catch(s){console.error("[ERROR] Failed to capture screenshot:",s),r({success:!1,error:s.message})}break;case"getCacheStats":try{const s=o.getStats();r({success:!0,stats:s})}catch(s){console.error("[ERROR] Failed to get cache stats:",s),r({success:!1,error:s.message})}break;case"setQualityTier":try{const s=e.tier||h.DEFAULT_QUALITY_TIER;ce(s)?(chrome.storage.local.set({qualityTier:s}),console.log(`[SETTINGS] Quality tier changed to: ${s}`),r({success:!0,tier:s})):r({success:!1,error:"Invalid quality tier"})}catch(s){console.error("[ERROR] Failed to set quality tier:",s),r({success:!1,error:s.message})}break;case"createGroup":try{if(e.tabId&&chrome.tabs.group){const s=await chrome.tabs.group({tabIds:e.tabId});r({success:!0,groupId:s})}else r({success:!1,error:"Missing tabId or API not supported"})}catch(s){console.error("[GROUPS] Failed to create group:",s),r({success:!1,error:s.message})}break;case"getTabsForFlow":try{const s=await chrome.windows.getCurrent(),u=(await chrome.tabs.query({windowId:s.id})).filter(l=>typeof l.id=="number");let d=[];if(chrome.tabGroups)try{d=await chrome.tabGroups.query({windowId:s.id})}catch(l){console.debug("[GROUPS] Failed to fetch groups:",l)}const m=Y(u),n=8,f=m.map((l,T)=>{let E=null;const S=T<n;if(v(l)&&S){const L=o.get(l.id);L&&(E=L)}return{id:l.id,title:l.title||"Untitled",url:l.url,favIconUrl:l.favIconUrl,screenshot:E?E.data:null,pinned:l.pinned,index:l.index,active:l.active,audible:l.audible,mutedInfo:l.mutedInfo,groupId:l.groupId,hasMedia:U(l.id)||l.audible}}),i=d.map(l=>({id:l.id,title:l.title,color:l.color,collapsed:l.collapsed}));r({success:!0,tabs:f,groups:i})}catch(s){console.error("[ERROR] Failed to get tabs for Flow:",s),r({success:!1,error:s.message})}break;default:console.warn("[WARNING] Unknown action:",e.action),r({success:!1,error:"Unknown action"})}}catch(s){console.error("[ERROR] Message handler failed:",s),r({success:!1,error:s.message})}}async function me(e,t,r=1){try{await chrome.tabs.sendMessage(e,t)}catch(o){if(r>0&&o.message&&o.message.includes("Could not establish connection")){console.log("[INJECT] Content script not ready, injecting...");try{await chrome.scripting.executeScript({target:{tabId:e},files:[ue]}),await new Promise(a=>setTimeout(a,150)),await chrome.tabs.sendMessage(e,t)}catch(a){const s=a&&a.message?a.message:"";if(s.includes("cannot be scripted")||s.includes("Cannot access a chrome://")||s.includes("Cannot access a chrome-extension://")||s.includes("Cannot access")&&s.includes("URL"))console.warn("[INJECT] Cannot inject on this page (protected URL). Try on a regular webpage.");else throw a}}else throw o}}const w=new K(h.MAX_CACHED_TABS,h.MAX_CACHE_BYTES);let y=null;async function fe(e,t,r){try{if(y!==null)try{if(await chrome.windows.get(y)){await chrome.windows.update(y,{focused:!0});try{chrome.runtime.sendMessage({action:"FlowPopupCycleNext"})}catch{}return}}catch{y=null}await chrome.storage.session.set({FlowTabData:{tabs:e,groups:t,activeTabId:r}});const o=await chrome.windows.getCurrent(),a=780,s=550,c=o.left!==void 0?Math.round(o.left+(o.width-a)/2):100,u=o.top!==void 0?Math.round(o.top+(o.height-s)/2):100,d=await chrome.windows.create({url:chrome.runtime.getURL("src/flow/index.html"),type:"popup",width:a,height:s,left:c,top:u,focused:!0});if(d?.id){y=d.id;const m=n=>{n===y&&(y=null,chrome.windows.onRemoved.removeListener(m))};chrome.windows.onRemoved.addListener(m)}console.log("[POPUP] Flow popup window created")}catch(o){console.error("[POPUP] Failed to create Flow popup:",o)}}async function ge(){console.log("═══════════════════════════════════════════════════════"),console.log("Visual Tab Flow - Performance Optimized (Modular)"),console.log("═══════════════════════════════════════════════════════"),console.log(`Cache: Max ${h.MAX_CACHED_TABS} tabs, ${(h.MAX_CACHE_BYTES/1024/1024).toFixed(2)}MB`),console.log(`Rate Limit: ${h.MAX_CAPTURES_PER_SECOND} captures/sec`),console.log("Target: <100ms overlay open, <50MB memory, 60fps"),console.log("═══════════════════════════════════════════════════════"),await q(),await ne(),setTimeout(async()=>{await ie(),await J();const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});e?.id&&M(e.id,w,!0)},100),await be()}async function be(){await chrome.alarms.clearAll(),chrome.alarms.create(h.ALARMS.IDLE_CHECK,{delayInMinutes:1,periodInMinutes:1}),chrome.alarms.create(h.ALARMS.PERF_LOG,{delayInMinutes:1,periodInMinutes:1}),console.log("[ALARMS] Periodic alarms set up successfully")}chrome.alarms.onAlarm.addListener(async e=>{switch(e.name){case h.ALARMS.IDLE_CHECK:await we();break;case h.ALARMS.PERF_LOG:A.logStats(w);break}});async function we(){try{const e=ee();if(!e)return;const t=300*1e3,r=te();Date.now()-r>t&&(console.debug(`[IDLE] Tab ${e} idle > 5m, refreshing screenshot`),$(),M(e,w,!0))}catch(e){console.debug("[IDLE] Error in idle check:",e)}}let O=null;typeof chrome<"u"&&chrome.tabs?(chrome.tabs.onActivated.addListener(async e=>{try{se(e.tabId),$(),H(e.tabId),O&&clearTimeout(O),O=setTimeout(()=>{M(e.tabId,w,!0),O=null},500)}catch(t){console.debug("[TAB] Error in onActivated:",t)}}),chrome.tabs.onUpdated.addListener((e,t,r)=>{try{t.audible!==void 0&&t.audible&&D(e),t.status==="complete"&&r.active&&setTimeout(()=>{M(e,w,!0)},300)}catch(o){console.debug("[TAB] Error in onUpdated:",o)}}),chrome.tabs.onCreated.addListener(e=>{try{e.id&&W(e.id)}catch(t){console.debug("[TAB] Error in onCreated:",t)}}),chrome.tabs.onRemoved.addListener(e=>{try{w.delete(e),G(e),oe(e),de(e),V(e),console.debug(`[CLEANUP] Removed tab ${e} from cache`)}catch(t){console.debug("[TAB] Error in onRemoved:",t)}})):console.error("[INIT] chrome.tabs API not available");typeof chrome<"u"&&chrome.commands&&chrome.commands.onCommand.addListener(e=>{(e==="show-tab-flow"||e==="cycle-next-tab")&&j()});async function j(){w.ready&&await w.ready,re()||await Q();const e=performance.now();try{try{const i=await chrome.windows.getCurrent(),[l]=await chrome.tabs.query({active:!0,windowId:i.id}),T=chrome.runtime.getURL("src/flow/index.html");if(i?.type==="popup"&&l?.url===T){chrome.runtime.sendMessage({action:"FlowPopupCycleNext"});return}}catch{}const t=await chrome.windows.getCurrent(),r=await chrome.tabs.query({windowId:t.id}),o=r.filter(i=>typeof i.id=="number");let a=[];if(chrome.tabGroups)try{a=await chrome.tabGroups.query({windowId:t.id})}catch(i){console.debug("[GROUPS] Failed to fetch groups:",i)}const s=Date.now();o.forEach((i,l)=>{Z(i.id)||W(i.id,s-(r.length-l)*1e3)});const c=Y(o),u=8,d=c.map((i,l)=>{let T=null;const E=l<u;if(v(i)&&E){const S=w.get(i.id);S?(T=S,A.cacheHits++):A.cacheMisses++}return{id:i.id,title:i.title||"Untitled",url:i.url,favIconUrl:i.favIconUrl,screenshot:T?T.data:null,pinned:i.pinned,index:i.index,active:i.active,audible:i.audible,mutedInfo:i.mutedInfo,groupId:i.groupId,hasMedia:U(i.id)||i.audible}}),m=a.map(i=>({id:i.id,title:i.title,color:i.color,collapsed:i.collapsed})),[n]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!n||typeof n.id!="number"){console.warn("[INJECT] No active tab found to open overlay");return}if(!v(n)){console.log("[INJECT] Protected page detected, opening popup window fallback..."),await fe(d,m,n.id);return}await me(n.id,{action:"showTabFlow",tabs:d,groups:m,activeTabId:n.id});const f=performance.now()-e;A.recordOverlayOpen(f)}catch(t){console.error("[ERROR] Failed to show Tab Flow:",t)}}typeof chrome<"u"&&chrome.runtime&&chrome.runtime.onMessage&&chrome.runtime.onMessage.addListener((e,t,r)=>(he(e,t,r,w,j),!0));ge().catch(e=>{console.error("[INIT] Failed to initialize:",e)});
